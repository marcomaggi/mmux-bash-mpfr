\input texinfo.tex
@c %**start of header
@setfilename mmux-bash-mpfr.info
@settitle MMUX Bash MPFR
@c %**end of header

@include version.texi
@include mmux-version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@macro mpfrref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,mpfr}
@end macro

@ifinfo
@macro mbfl{}
@acronym{MBFL}
@end macro
@end ifinfo
@ifnotinfo
@macro mbfl{}
@acronym{mbfl}
@end macro
@end ifnotinfo

@ifinfo
@macro mmux{}
@acronym{MMUX}
@end macro
@end ifinfo
@ifnotinfo
@macro mmux{}
@acronym{mmux}
@end macro
@end ifnotinfo

@ifinfo
@macro mpfr{}
@acronym{MPFR}
@end macro
@end ifinfo
@ifnotinfo
@macro mpfr{}
@acronym{mpfr}
@end macro
@end ifnotinfo

@macro WW{VARNAME}
$@{\VARNAME\:?@}
@end macro

@macro MpfrBuiltin{NAME}
@code{\NAME\}
@end macro

@macro MmuxBuiltin{NAME}
@code{\NAME\}
@end macro

@macro MmuxBashPointersRef{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,mmux-bash-pointers}
@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineNullaryBuiltin{FUNC}
@deffn Builtin \FUNC\ @var{MPFR_ROP} @var{MPFR_RND}
Interface to the C language function @cfunc{\FUNC\}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineUnaryBuiltin{FUNC}
@deffn Builtin \FUNC\ @var{MPFR_ROP} @var{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{\FUNC\}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineUnaryNorndBuiltin{FUNC}
@deffn Builtin \FUNC\ @var{MPFR_ROP} @var{MPFR_OP}
Interface to the C language function @cfunc{\FUNC\}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineUnarySiBuiltin{FUNC}
@deffn Builtin \FUNC\ @var{MPFR_ROP} @var{SLONG_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{\FUNC\}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineUnaryUiBuiltin{FUNC}
@deffn Builtin \FUNC\ @var{MPFR_ROP} @var{ULONG_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{\FUNC\}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineUnarySjBuiltin{FUNC}
@deffn Builtin \FUNC\ @var{MPFR_ROP} @var{SINTMAX_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{\FUNC\}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineUnaryUjBuiltin{FUNC}
@deffn Builtin \FUNC\ @var{MPFR_ROP} @var{UINTMAX_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{\FUNC\}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineUnaryZBuiltin{FUNC}
@deffn Builtin \FUNC\ @var{MPFR_ROP} @var{MPZ_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{\FUNC\}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineBinaryBuiltin{FUNC}
@deffn Builtin \FUNC\ @var{MPFR_ROP} @vari{MPFR_OP} @varii{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{\FUNC\}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineBinarySiBuiltin{FUNC}
@deffn Builtin \FUNC\ @var{MPFR_ROP} @vari{MPFR_OP} @varii{SLONG_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{\FUNC\}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineBinaryUiBuiltin{FUNC}
@deffn Builtin \FUNC\ @var{MPFR_ROP} @vari{MPFR_OP} @varii{ULONG_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{\FUNC\}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineBinarySjBuiltin{FUNC}
@deffn Builtin \FUNC\ @var{MPFR_ROP} @vari{MPFR_OP} @varii{SINTMAX_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{\FUNC\}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineBinaryUjBuiltin{FUNC}
@deffn Builtin \FUNC\ @var{MPFR_ROP} @vari{MPFR_OP} @varii{UINTMAX_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{\FUNC\}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineBinaryZBuiltin{FUNC}
@deffn Builtin \FUNC\ @var{MPFR_ROP} @vari{MPFR_OP} @varii{MPZ_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{\FUNC\}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineUiBinaryUiBuiltin{FUNC}
@deffn Builtin \FUNC\ @var{MPFR_ROP} @vari{ULONG_OP} @varii{ULONG_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{\FUNC\}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineSiBinaryBuiltin{FUNC}
@deffn Builtin \FUNC\ @var{MPFR_ROP} @vari{SLONG_OP} @varii{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{\FUNC\}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineUiBinaryBuiltin{FUNC}
@deffn Builtin \FUNC\ @var{MPFR_ROP} @vari{ULONG_OP} @varii{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{\FUNC\}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineTernaryUiBuiltin{FUNC}
@deffn Builtin \FUNC\ @var{MPFR_ROP} @vari{MPFR_OP} @varii{MPFR_OP} @varii{ULONG_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{\FUNC\}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefinePredicateBuiltinNoEnd{FUNC}
@deffn Builtin \FUNC\ @var{MPFR_OP}
Interface to the C language function @cfunc{\FUNC\}.  When successful return true; otherwise return
false.  To check the result we have to use the shell variable @env{MPFR_RV}.
@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefinePredicateBuiltin{FUNC}
@MmuxDefinePredicateBuiltinNoEndNoEnd{FUNC}
@end deffn

@end macro


@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      @mmux{} Bash @mpfr{}

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    @mmux{} Bash @mpfr{}

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmux-bash-mpfr

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2024

@c ------------------------------------------------------------

@set PackageAutoconfPrefix              MMUX_BASH_MPFR
@set PackagePkgconfigModule             mmux-bash-mpfr
@set PackageLibsVar                     @env{MMUX_BASH_MPFR_LIBS}
@set PackageCflagsVar                   @env{MMUX_BASH_MPFR_CFLAGS}
@c This is the stem of the library in "libmmux-bash-mpfr.so".
@set PackageLibstem                     mmux-bash-mpfr
@set PackageApiPrefixLower              mmux_bash_mpfr_
@set PackageApiPrefixUpper              MMUX_BASH_MPFR_

@set PackageHeader                      mmux-bash-mpfr.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{MmuxPkgSemanticVersion} of @value{PACKAGE}, a package
implementing loadable builtin commands for the @gnu{} Bash shell; to do so it installs a C11
language library and a shell script which is meant to be sourced in a Bash session or script.

This package provides an interface to the @emph{Multiple Precision Floating--Point Reliable
Library}, @mpfr{}.

This package is distributed under the terms of the @gnu{} General Public License (@gpl{}).

Development of this package takes place at:

@center @value{GithubUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} Lesser
General Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mmux-bash-mpfr: (mmux-bash-mpfr).     Additional GNU Bash builtins.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* descriptors::                 @mmux{} package descriptors.
* variables::                   Global variables.
* init::                        Initialisation and finalisation.
* assignment::                  Assignment builtins.
* conversion::                  Converting numbers to other representations.
* arithmetic::                  Arithmetic builtins.
* comparison::                  Comparison builtins.
* transcendental::              Transcendental builtins.
* io::                          Input, output, printing.
* integers::                    Integers builtins.
* rounding::                    Rounding-related builtins.
* stepping::                    Stepping builtins.
* sign::                        Sign of numbers builtins.
* exponents::                   Exponents-related builtins.
* miscellaneous::               Miscellaneous builtins.
* build options::               Build options builtins.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* shared library::              Using the shared library.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{MmuxPkgSemanticVersion} of @value{PACKAGE}, a package
implementing loadable builtin commands for the @gnu{} Bash shell; to do so it installs a C11
language library and a shell script which is meant to be sourced in a Bash session or script.

This package provides an interface to the @emph{Multiple Precision Floating--Point Reliable
Library}, @mpfr{}.

@example
source mmux-bash-packages
source mmux-bash-pointers
source mmux-bash-mpfr

declare OP

mpfr_alloc_and_init OP
mpfr_set_d @WW{OP} '1.23' @WW{MPFR_RNDN}
mpfr_just_printit_dammit @WW{OP}
mpfr_clear_and_free @WW{OP}
@end example

This package depends upon the facilities of the external package @mmux{} Bash Pointers, @xref{Top,
@mmux{} Bash Pointers, @mmux{} Bash Pointers, mmux-bash-pointers}.

@menu
* overview install::            Installed files.
* overview linking::            Linking code with the library.
* overview conventions::        Conventions used in this documentation.
* overview retvals::            Return values of @mpfr{} functions.
@end menu

@c page
@node overview install
@section Installed files


@value{PACKAGE} installs a shell script, a ``shell library'', under @code{$datavar/bash}; for
example:

@example
/usr/local/share/bash/libmmux-bash-mpfr.bash
@end example

@noindent
to use the builtins, we have to load the shell library using Bash's builtin @code{source}.  A shared
library, actually implementing the builtins, is installed under @code{$libdir}; for example:

@example
/usr/local/lib64/libmmux-bash-mpfr.so
@end example

@noindent
the shared library is automatically loaded by the shell library using Bash's @MmuxBuiltin{enable}
builtin.

C11 language header files are also installed under @code{$includedir}, for example the main one
could be:

@example
/usr/local/include/mmux-bash-mpfr.h
@end example

@noindent
we can write code that links to the shared library to reuse some of its facilities.

@c page
@c external documents

@include overview-linking.texi

@c page
@node overview conventions
@section Conventions used in this documentation


@macro MmuxBashMpfrArgConventionPlain{STEM,LOSTEM}
@item \STEM\
@cindex \STEM\, builtin argument
@cindex builtin argument \STEM\
@cindex argument \STEM\, for builtins
A string representation of a value of type @objtype{mmux_\LOSTEM\_t}.

@end macro

The following naming conventions for builtin and function parameters are used in this documentation:

@table @var
@item MPFR_PTR
@itemx MPFR_OP
@itemx MPFR_ROP
@cindex MPFR_PTR, builtin argument
@cindex builtin argument MPFR_PTR
@cindex argument MPFR_PTR, for builtins
@cindex MPFR_OP, builtin argument
@cindex builtin argument MPFR_OP
@cindex argument MPFR_OP, for builtins
A string representation of a pointer referencing an instance of @objtype{__mpfr_struct}.

@item MPFR_PTRVAR
@cindex MPFR_PTRVAR, builtin argument
@cindex builtin argument MPFR_PTRVAR
@cindex argument MPFR_PTRVAR, for builtins
The string representation of a shell variable name: the builtin taking it as parameter, when
successful, will store in the variable a string representation of a pointer referencing an instance
of @objtype{__mpfr_struct}.  If the builtin fails: the shell variable is left untouched.

@item MPFR_RND
@cindex MPFR_RND, builtin argument
@cindex builtin argument MPFR_RND
@cindex argument MPFR_RND, for builtins
A string representation of one of the @mpfr{} constants @samp{MPFR_RND*}.

@item MPFR_RNDVAR
@cindex MPFR_RNDVAR, builtin argument
@cindex builtin argument MPFR_RNDVAR
@cindex argument MPFR_RND, for builtins
The string representation of a shell variable name: the builtin taking it as parameter, when
successful, will store in the variable the string representation of a value of type
@objtype{mpfr_rnd_t}.  If the builtin fails: the shell variable is left untouched.

@item MPFR_EXP
@cindex MPFR_EXP, builtin argument
@cindex builtin argument MPFR_EXP
@cindex argument MPFR_EXP, for builtins
A string representation of a value of type @objtype{mpfr_exp_t}.

@item MPFR_EXPVAR
@cindex MPFR_EXPVAR, builtin argument
@cindex builtin argument MPFR_EXPVAR
@cindex argument MPFR_EXP, for builtins
The string representation of a shell variable name: the builtin taking it as parameter, when
successful, will store in the variable the string representation of a value of type
@objtype{mpfr_exp_t}.  If the builtin fails: the shell variable is left untouched.

@item MPFR_PREC
@cindex MPFR_PREC, builtin argument
@cindex builtin argument MPFR_PREC
@cindex argument MPFR_PREC, for builtins
A string representation of a value of type @objtype{mpfr_prec_t}.

@item MPFR_PRECVAR
@cindex MPFR_PRECVAR, builtin argument
@cindex builtin argument MPFR_PRECVAR
@cindex argument MPFR_PREC, for builtins
The string representation of a shell variable name: the builtin taking it as parameter, when
successful, will store in the variable the string representation of a value of type
@objtype{mpfr_prec_t}.  If the builtin fails: the shell variable is left untouched.

@item STRVAR
@cindex MPFR_STRVAR, builtin argument
@cindex builtin argument MPFR_STRVAR
@cindex argument MPFR_STRVAR, for builtins
The string representation of a shell variable name: the builtin taking it as parameter, when
successful, will store in the variable a generated string.  If the builtin fails: the shell variable
is left untouched.

@item MPF_PTR
@itemx MPF_OP
@itemx MPF_ROP
@cindex MPF_PTR, builtin argument
@cindex builtin argument MPF_PTR
@cindex argument MPF_PTR, for builtins
@cindex MPF_OP, builtin argument
@cindex builtin argument MPF_OP
@cindex argument MPF_OP, for builtins
@cindex MPF_ROP, builtin argument
@cindex builtin argument MPF_ROP
@cindex argument MPF_ROP, for builtins
A string representation of a pointer of type @objtype{mpf_ptr}.

@item MPQ_PTR
@itemx MPQ_OP
@itemx MPQ_ROP
@cindex MPQ_PTR, builtin argument
@cindex builtin argument MPQ_PTR
@cindex argument MPQ_PTR, for builtins
@cindex MPQ_OP, builtin argument
@cindex builtin argument MPQ_OP
@cindex argument MPQ_OP, for builtins
A string representation of a pointer of type @objtype{mpq_ptr}.

@item MPZ_PTR
@itemx MPZ_OP
@itemx MPZ_ROP
@cindex MPZ_PTR, builtin argument
@cindex builtin argument MPZ_PTR
@cindex argument MPZ_PTR, for builtins
@cindex MPZ_OP, builtin argument
@cindex builtin argument MPZ_OP
@cindex argument MPZ_OP, for builtins
@cindex MPZ_ROP, builtin argument
@cindex builtin argument MPZ_ROP
@cindex argument MPZ_ROP, for builtins
A string representation of a pointer of type @objtype{mpz_ptr}.

@MmuxBashMpfrArgConventionPlain{SLONG,slong}
@MmuxBashMpfrArgConventionPlain{ULONG,ulong}
@MmuxBashMpfrArgConventionPlain{SINTMAX,sintmax}
@MmuxBashMpfrArgConventionPlain{UINTMAX,uintmax}
@MmuxBashMpfrArgConventionPlain{FLOAT,float}
@MmuxBashMpfrArgConventionPlain{DOUBLE,double}
@MmuxBashMpfrArgConventionPlain{LDOUBLE,ldouble}
@MmuxBashMpfrArgConventionPlain{FLOAT128,float128}
@MmuxBashMpfrArgConventionPlain{DECIMAL64,decimal64}
@MmuxBashMpfrArgConventionPlain{DECIMAL128,decimal128}
@end table

@c page
@node overview retvals
@section Return values of @mpfr{} functions


Every function and builtin defined by the shell library returns a meaningful value: true when
successful, false otherwise.  Among the reasons for returning false: wrong number of arguments;
invalid argument type.

@cindex @code{ERRNO}, shell variable
@cindex variable @code{ERRNO}, shell variable
@cindex shell variable @code{ERRNO}
If a builtin performs a call to a system function: that function might set the standard C language
@code{errno} variable; the builtin consumes the value, it clears @code{errno}, it might set the
shell variable @code{ERRNO} (when documented to do so), it returns false.

@cindex @code{ERRNO}, shell variable
@cindex shell variable @code{ERRNO}
If an argument to builtin is invalid: the builtin returns false and sets the shell variable
@code{ERRNO} to @samp{EINVAL}.

Many @mpfr{} C language functions return a value, called the ``ternary value'', @mpfrref{ternary
value, Rounding}.  Other @mpfr{} C language functions return an integer value that is to be
interpreted as a boolean value.  The corresponding builtin reserves the return value to signal if an
error occurred.  Ternary values and boolean values are stored in a shell variable named
@code{MPFR_RV}.

@example
declare -a OPS

mpfr_alloc_and_init_shell_array OPS 3
@{
    declare -n ROP='OPS[0]' OP1='OPS[1]' OP2='OPS[2]'
    declare MPFR_RV

    mpfr_set_si @WW{OP1} 123 @WW{MPFR_RNDN}
    mpfr_set_si @WW{OP2} 456 @WW{MPFR_RNDN}

    mpfr_add @WW{ROP} @WW{OP1} @WW{OP2} @WW{MPFR_RNDN}
    printf '%d\n' "@WW{MPFR_RV}"  @print{} [whatever is returned by the C function mpfr_add()]
@}
mpfr_clear_and_free_shell_array OPS
@end example


@c page
@node descriptors
@chapter @mmux{} package descriptors


@cindex Package descriptor for @value{PACKAGE}


@value{PACKAGE} adheres to the requirements of the @mmux{} Bash Packages Infrastructure,
@MmuxBashPointersRef{packages, @mmux{} Bash Packages Infrastructure}.  As such the library
@file{libmmux-bash-mpfr.bash} defines a package descriptor holding basic informations about the
exported @api{}.

The @api{} follows version numbering as established by the @gnu{} Autotools.  For an explanation of
interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface, Libtool's
versioning system, libtool, Shared library support for @gnu{}}.


@defvr {Associative Shell Array} MMUX_BASH_MPFR_PACKAGE
A descriptor representing informations about the package.

For details on the defined keys @MmuxBashPointersRef{packages descriptor, Package descriptor}.
@end defvr

@c page
@node variables
@chapter Global variables


The shell library installed by @value{PACKAGE} defines global variables to allow inspection of the
underlying C language platform.

@menu
* variables version::           @mpfr{} version numbers.
* variables sizeof::            C language type sizes.
* variables constants::         C language constants.
@end menu

@c page
@node variables version
@section @mpfr{} version numbers


@defvar MPFR_VERSION
A string representing @mpfr{} version number.
@end defvar


@defvar MPFR_VERSION_MAJOR
@defvarx MPFR_VERSION_MINOR
@defvarx MPFR_VERSION_PATCHLEVEL
Exact integers representing @mpfr{} version numbers.
@end defvar

@c page
@node variables sizeof
@section C language type sizes


If a C language type referenced by one of the following variables is undefined: the corresponding
Bash variable is undefined; we can test this condition with @code{test -v}:

@example
if test -v mpfr_SIZEOF
then # implemented
else # not implemented
fi
@end example

@macro MmuxDefineGlobalVarSizeof{NAME,TYPE}
@defvar \NAME\_SIZEOF
Global variable holding the size, measured in bytes, of the C language type @code{\TYPE\}.
@end defvar

@end macro

@MmuxDefineGlobalVarSizeof{mpfr, __mpfr_struct}
@MmuxDefineGlobalVarSizeof{mpfr_exp, mpfr_exp_t}
@MmuxDefineGlobalVarSizeof{mpfr_rnd, mpfr_rnd_t}
@MmuxDefineGlobalVarSizeof{mpfr_prec, mpfr_prec_t}

@c page
@node variables constants
@section C language constants


If a C language constant referenced by one of the following variables is undefined: the
corresponding Bash variable is undefined; we can test this condition with @code{test -v}; to test if
the underlying platform implements the constant @code{MPFR_RNDN}, we can do:

@example
if test -v MPFR_RNDN
then # implemented
else # not implemented
fi
@end example

@macro MmuxDefineGlobalVarConstant{NAME}
@defvar \NAME\
Global variable holding the value of the C language constant @code{\NAME\}.
@end defvar

@end macro

@MmuxDefineGlobalVarConstant{MPFR_RNDN}
@MmuxDefineGlobalVarConstant{MPFR_RNDZ}
@MmuxDefineGlobalVarConstant{MPFR_RNDU}
@MmuxDefineGlobalVarConstant{MPFR_RNDD}
@MmuxDefineGlobalVarConstant{MPFR_RNDA}
@MmuxDefineGlobalVarConstant{MPFR_RNDF}
@MmuxDefineGlobalVarConstant{MPFR_RNDNA}


@defvar mpfr_prec_MAX
@defvarx mpfr_prec_MIN
The minimum and maximum vales for values of type @objtype{mpfr_prec_t}.  These values are the C
language constants @code{MPFR_PREC_MAX} and @code{MPFR_PREC_MIN}.
@end defvar

@c page
@node init
@chapter Initialisation and finalisation


@menu
* init basic::                  Basic initialisation and finalisation.
* init shell array::            Shell index array initialisation and finalisation.
* init pointers array::         Raw memory pointers array initialisation and finalisation.
* init precision::              Handling @mpfr{} numbers precision.
@end menu

@c page
@node init basic
@section Basic initialisation and finalisation


@ref{overview conventions, Conventions used in this documentation}.


@deffn Builtin mpfr_init @var{MPFR_PTR}
@deffnx Builtin mpfr_init2 @var{MPFR_PTR} @var{MPFR_PREC}
@deffnx Builtin mpfr_clear @var{MPFR_PTR}
Interfaces to the C language functions @cfunc{mpfr_init}, @cfunc{mpfr_init2}, @cfunc{mpfr_init}.

@example
declare OP1 OP2

mmux_libc_calloc OP 1 @WW{mpfr_SIZEOF}
@{
    mpfr_init @WW{OP}
    @{
        mpfr_set_si @WW{OP} 123 @WW{MPFR_RNDN}
        mpfr_just_printit_dammit @WW{OP}
    @}
    mpfr_clear @WW{OP}
@}
mmux_libc_free @WW{OP}
@end example
@end deffn


@deffn Builtin mpfr_inits @varo{MPFR_PTR} @var{MPFR_PTR} @dots{}
@deffnx Builtin mpfr_inits2 @var{MFPR_PREC} @varo{MPFR_PTR} @var{MPFR_PTR} @dots{}
@deffnx Builtin mpfr_clears @varo{MPFR_PTR} @var{MPFR_PTR} @dots{}
Interfaces to the C language functions @cfunc{mpfr_inits}, @cfunc{mpfr_inits2}, @cfunc{mpfr_clears}.

@example
declare OP1 OP2

mmux_libc_calloc 2 OP1 @WW{mpfr_SIZEOF}
@{
    mmux_pointer_add OP2 @WW{OP1} @WW{mpfr_SIZEOF}

    mpfr_inits @WW{OP1} @WW{OP2}
    @{
        mpfr_set_si @WW{OP1} -12 @WW{MPFR_RNDN}
        mpfr_set_ui @WW{OP2} +34 @WW{MPFR_RNDN}
        mpfr_just_printit_dammit @WW{OP1}
        mpfr_just_printit_dammit @WW{OP2}
    @}
    mpfr_clears @WW{OP1} @WW{OP2}
@}
mmux_libc_free @WW{OP1}
@end example
@end deffn


It is possible to allocate and initialise a @mpfr{} number with a single function call:

@example
declare OP

mpfr_alloc_and_init OP
@{
    mpfr_set_si @WW{OP} 123 @WW{MPFR_RNDN}
    mpfr_just_printit_dammit @WW{OP}
@}
mpfr_clear_and_free @WW{OP}
@end example


@defun mpfr_alloc_and_init @var{MPFR_PTRVAR}
@defunx mpfr_alloc_and_init @var{MPFR_PTRVAR} @var{MPFR_PREC}
Allocate a new block of memory to hold the data structure of a @mpfr{} number; initialise the
number; store a pointer to the structure in @var{MPFR_PTRVAR}.

When the optional parameter @var{MPFR_PREC} is present: it is used as precision value to initialise
the number.
@end defun


@defun mpfr_clear_and_free @var{MPFR_PTR}
Clear the number referenced by the pointer then release the associated memory; it is meant to be
applied to the pointer generated by @func{mpfr_alloc_and_init}.
@end defun

@c page
@node init shell array
@section Shell index array initialisation and finalisation


It is possible to allocate a single block of memory for the data structures of multiple @mpfr{}
numbers; then we can initialise and finalise all the numbers with a single function call.  Such
blocks of memory are handled through a shell index array.

To allocate with a single function call and initialise with another single function call:

@example
declare -a OPS
declare -i DIM=5

mpfr_alloc_shell_array OPS @WW{DIM}
@{
    mpfr_init_shell_array OPS
    @{
        declare -i IDX

        for ((IDX=0; IDX < $@{#OPS[@@]@}; ++IDX))
        do mpfr_set_si $@{OPS[@WW{IDX}]:?@} @WW{IDX} @WW{MPFR_RNDN}
        done

        # We can access the individual numbers.
        declare -n ROP=OPS[0] OP1=OPS[1] OP2=OPS[2]

        mpfr_just_printit_dammit @WW{ROP}
        mpfr_just_printit_dammit @WW{OP1}
        mpfr_just_printit_dammit @WW{OP2}
    @}
    mpfr_clear_shell_array OPS
@}
mpfr_free_shell_array OPS
@end example

To allocate and initialise with a single function call:

@example
declare -a OPS
declare -i DIM=5 IDX

mpfr_alloc_and_init_shell_array OPS @WW{DIM}
@{
    for ((IDX=0; IDX < $@{#OPS[@@]@}; ++IDX))
    do mpfr_set_si $@{OPS[@WW{IDX}]:?@} @WW{IDX} @WW{MPFR_RNDN}
    done

    # We can access the individual numbers.
    declare -n ROP=OPS[0] OP1=OPS[1] OP2=OPS[2]

    mpfr_just_printit_dammit @WW{ROP}
    mpfr_just_printit_dammit @WW{OP1}
    mpfr_just_printit_dammit @WW{OP2}
@}
mpfr_clear_and_free_shell_array OPS
@end example

@ref{overview conventions, Conventions used in this documentation}.


@defun mpfr_alloc_shell_array @var{ARRYNAME} @var{DIM}
Allocate a single block of memory capable of holding @var{DIM} data structures each representing an
@mpfr{} number; store the pointers to the structures in the shell index array whose name is
@var{ARRYNAME}; the element at index @samp{0} holds the pointer to the memory block itself.
@end defun


@defun mpfr_free_shell_array @var{ARRYNAME}
Release the memory allocated by @func{mpfr_alloc_shell_array}; @var{ARRYNAME} must be the name of
the shell index array used to reference the memory block.
@end defun


@defun mpfr_init_shell_array @var{ARRYNAME}
@defunx mpfr_init_shell_array @var{ARRYNAME} @var{MPFR_PREC}
Initialise each @mpfr{} number whose pointer is stored in the shell index array named
@var{ARRYNAME}; the shell array itself must have been initialised by @func{mpfr_alloc_shell_array}.

When the optional parameter @var{MPFR_PREC} is present: is it used as precision to initialise all
the numbers.
@end defun


@defun mpfr_clear_shell_array @var{ARRYNAME}
Clear each @mpfr{} number whose pointer is stored in the shell index array named @var{ARRYNAME}; the
shell array itself must have been initialised by @func{mpfr_init_shell_array}.

This function only clears the numbers: to release the allocated memory we must use
@func{mpfr_free_shell_array}.
@end defun


@defun mpfr_alloc_and_init_shell_array @var{ARRYNAME} @var{DIM}
@defunx mpfr_alloc_and_init_shell_array @var{ARRYNAME} @var{DIM} @var{MPFR_PREC}
Perform the calls:

@example
mpfr_alloc_shell_array @var{ARRYNAME} @var{DIM}
mpfr_init_shell_array  @var{ARRYNAME} @var{MPFR_PREC}
@end example

@noindent
checking for errors.
@end defun


@defun mpfr_clear_and_free_shell_array @var{ARRYNAME}
Perform the calls:

@example
mpfr_clear_shell_array @var{ARRYNAME}
mpfr_free_shell_array  @var{ARRYNAME}
@end example

@noindent
checking for errors.
@end defun

@c page
@node init pointers array
@section Raw memory pointers array initialisation and finalisation


@ref{overview conventions, Conventions used in this documentation}.


@defun mpfr_alloc_and_init_pointers_array @var{POINTERS_VAR} @var{ARRYNAME}
Allocate a new raw memory block and store a pointer to it in the shell variable @var{POINTERS_VAR};
we can release the memory block with a call to @MpfrBuiltin{mmux_libc_free}.

The argument @var{ARRYNAME} must be the name of a shell index array previously allocated and
initialised as explained in @ref{init shell array, Shell index array initialisation and
finalisation}.

The new memory block is an array of pointers with the same dimension of @var{ARRYNAME} and the same
values of @var{ARRYNAME}.  We can use a pointer to such raw memory array as argument to the builtins
@MpfrBuiltin{mpfr_sum} and @MpfrBuiltin{mpfr_dot}.

@example
declare -a OPS
declare -i DIM=5
declare POINTERS

mpfr_alloc_and_init_shell_array OPS @WW{DIM}
@{
    mpfr_alloc_and_init_pointers_array POINTERS OPS
    @{
        # do something with the pointers
        declare ROP OP

        mmux_pointer_array_ref ROP @WW{POINTERS} 0
        mmux_pointer_array_ref  OP @WW{POINTERS} 1
        # ...
    @}
    mmux_libc_free @WW{POINTERS}
@}
mpfr_clear_and_free_shell_array OPS
@end example
@end defun

@c page
@node init precision
@section Handling @mpfr{} numbers precision


@ref{overview conventions, Conventions used in this documentation}.


@defun mpfr_set_default_prec @var{MPFR_PREC}
@defunx mpfr_get_default_prec @var{MPFR_PREC_VAR}
Interfaces to the C language functions @cfunc{mpfr_set_default_prec}, @cfunc{mpfr_get_default_prec}.

@example
declare -r NEW_PREC=17
declare PREC

mpfr_set_default_prec @WW{NEW_PREC}
mpfr_get_default_prec PREC
@WW{PREC}   @result{} 17
@end example
@end defun


@defun mpfr_set_prec @var{MPFR_OP} @var{MPFR_PREC}
@defunx mpfr_get_prec @var{MPFR_PREC_VAR} @var{MPFR_OP}
Interfaces to the C language functions @cfunc{mpfr_set_prec}, @cfunc{mpfr_get_prec}.
@end defun

@c page
@node assignment
@chapter Assignment builtins


To assign a value to a number we do:

@example
declare OP

mpfr_alloc_and_init OP
@{
    mpfr_set_d @WW{OP} '1.23' @WW{MPFR_RNDN}
    mpfr_just_printit_dammit @WW{OP}
@}
mpfr_clear_and_free @WW{OP}
@end example

@c ------------------------------------------------------------------------

@macro MmuxMpfrAssignmentBuiltin{FUNC,ARGSTEM}
@deffn Builtin \FUNC\ @var{MPFR_ROP} @var{\ARGSTEM\} @var{MPFR_RND}
Interface to the C language functions @cfunc{\FUNC\}.
@end deffn

@end macro

@macro MmuxMpfrAssignmentTwoExpBuiltin{FUNC,ARGSTEM}
@deffn Builtin \FUNC\ @var{MPFR_ROP} @var{\ARGSTEM\} @var{MPFR_EXP} @var{MPFR_RND}
Interface to the C language functions @cfunc{\FUNC\}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@ref{overview conventions, Conventions used in this documentation}.

@MmuxMpfrAssignmentBuiltin{mpfr_set_si, SLONG}
@MmuxMpfrAssignmentBuiltin{mpfr_set_ui, ULONG}
@MmuxMpfrAssignmentBuiltin{mpfr_set_sj, SINTMAX}
@MmuxMpfrAssignmentBuiltin{mpfr_set_uj, UINTMAX}
@MmuxMpfrAssignmentBuiltin{mpfr_set_flt, FLOAT}
@MmuxMpfrAssignmentBuiltin{mpfr_set_d, DOUBLE}
@MmuxMpfrAssignmentBuiltin{mpfr_set_ld, LDOUBLE}
@MmuxMpfrAssignmentBuiltin{mpfr_set_float128, FLOAT128}
@MmuxMpfrAssignmentBuiltin{mpfr_set_decimal64, decimal64}
@MmuxMpfrAssignmentBuiltin{mpfr_set_decimal128, decimal128}
@MmuxMpfrAssignmentBuiltin{mpfr_set_z, MPZ_OP}
@MmuxMpfrAssignmentBuiltin{mpfr_set_q, MPQ_OP}
@MmuxMpfrAssignmentBuiltin{mpfr_set_f, MPF_OP}
@MmuxMpfrAssignmentBuiltin{mpfr_set, MPFR_OP}

@MmuxMpfrAssignmentTwoExpBuiltin{mpfr_set_si_2exp, SLONG}
@MmuxMpfrAssignmentTwoExpBuiltin{mpfr_set_ui_2exp, ULONG}
@MmuxMpfrAssignmentTwoExpBuiltin{mpfr_set_sj_2exp, SINTMAX}
@MmuxMpfrAssignmentTwoExpBuiltin{mpfr_set_uj_2exp, UINTMAX}
@MmuxMpfrAssignmentTwoExpBuiltin{mpfr_set_z_2exp, MPZ_PTR}


@deffn Builtin mpfr_set_str @var{MPFR_ROP} @var{STRING} @var{BASE} @var{MPFR_RND}
Interface to the C language functions @cfunc{mpfr_set_str}.

@example
declare -r STR='1234567890' BASE='10'
declare OP

mpfr_alloc_and_init OP
@{
    mpfr_set_str @WW{OP} @WW{STR} @WW{BASE} @WW{MPFR_RNDN}
    mpfr_just_printit_dammit @WW{OP}
@}
mpfr_clear_and_free @WW{OP}
@end example
@end deffn


@deffn Builtin mpfr_set_nan @var{MPFR_OP}
Interface to the C language functions @cfunc{mpfr_set_nan}.
@end deffn


@deffn Builtin mpfr_set_inf @var{MPFR_OP} @var{SIGN}
Interface to the C language functions @cfunc{mpfr_set_inf}.  The argument sign must be one among
@samp{+1}, @samp{0}, @samp{-1}.

@example
declare OP

mpfr_alloc_and_init OP
@{
    mpfr_set_inf @WW{OP} +1
    mpfr_just_printit_dammit @WW{OP}
@}
mpfr_clear_and_free @WW{OP}
@end example
@end deffn


@deffn Builtin mpfr_set_zero @var{MPFR_OP} @var{SIGN}
Interface to the C language functions @cfunc{mpfr_set_zero}.  The argument sign must be one among
@samp{+1}, @samp{0}, @samp{-1}.

@example
declare OP

mpfr_alloc_and_init OP
@{
    mpfr_set_zero @WW{OP} +1
    mpfr_just_printit_dammit @WW{OP}
@}
mpfr_clear_and_free @WW{OP}
@end example
@end deffn


@deffn Builtin mpfr_swap @vari{MPFR_OP} @varii{MPFR_OP}
Interface to the C language functions @cfunc{mpfr_swap}.
@end deffn


@macro MmuxInitAndSetBuiltin{FUNC,ARGSTEM}
@deffn Builtin \FUNC\ @var{MPFR_ROP} @var{\ARGSTEM\} @var{MPFR_RND}
Interface to the C language functions @cfunc{\FUNC\}.
@end deffn

@end macro

@MmuxInitAndSetBuiltin{mpfr_init_set_si,SLONG}
@MmuxInitAndSetBuiltin{mpfr_init_set_ui,ULONG}
@MmuxInitAndSetBuiltin{mpfr_init_set_d,DOUBLE}
@MmuxInitAndSetBuiltin{mpfr_init_set_ld,LDOUBLE}
@MmuxInitAndSetBuiltin{mpfr_init_set_z,MPZ_PTR}
@MmuxInitAndSetBuiltin{mpfr_init_set_q,MPQ_PTR}
@MmuxInitAndSetBuiltin{mpfr_init_set_f,MPF_PTR}
@MmuxInitAndSetBuiltin{mpfr_init_set,MPFR_PTR}

@c page
@node conversion
@chapter Converting numbers to other representations


To extract a value from a @mpfr{} number, we do:

@example
declare VAL OP MPFR_RV

mpfr_alloc_and_init OP
@{
    mpfr_set_si @WW{OP} '123' @WW{MPFR_RNDN}

    mpfr_fits_slong_p @WW{OP}
    if (( 1 == @WW{MPFR_RV} ))
    then
        mpfr_get_si VAL @WW{OP} @WW{MPFR_RNDN}
        printf '%s\n' @WW{VAL}
    fi
@}
mpfr_clear_and_free @WW{OP}
@end example

@ref{overview conventions, Conventions used in this documentation}.

@c ------------------------------------------------------------------------

@macro MmuxMpfrDefineGetter{BUILTIN,ARGS}
@deffn Builtin \BUILTIN\ \ARGS\
Interface to the C language function @cfunc{\BUILTIN\}.
@end deffn

@end macro

@MmuxMpfrDefineGetter{mpfr_get_si, @var{SLONG_VAR} @var{MPFR_OP} @var{MPFR_RND}}
@MmuxMpfrDefineGetter{mpfr_get_ui, @var{ULONG_VAR} @var{MPFR_OP} @var{MPFR_RND}}
@MmuxMpfrDefineGetter{mpfr_get_sj, @var{SINTMAX_VAR} @var{MPFR_OP} @var{MPFR_RND}}
@MmuxMpfrDefineGetter{mpfr_get_uj, @var{UINTMAX_VAR} @var{MPFR_OP} @var{MPFR_RND}}
@MmuxMpfrDefineGetter{mpfr_get_flt, @var{FLOAT_VAR} @var{MPFR_OP} @var{MPFR_RND}}
@MmuxMpfrDefineGetter{mpfr_get_d, @var{DOUBLE_VAR} @var{MPFR_OP} @var{MPFR_RND}}
@MmuxMpfrDefineGetter{mpfr_get_ld, @var{LDOUBLE_VAR} @var{MPFR_OP} @var{MPFR_RND}}
@MmuxMpfrDefineGetter{mpfr_get_float128, @var{FLOAT128_VAR} @var{MPFR_OP} @var{MPFR_RND}}
@MmuxMpfrDefineGetter{mpfr_get_decimal64, @var{DECIMAL64_VAR} @var{MPFR_OP} @var{MPFR_RND}}
@MmuxMpfrDefineGetter{mpfr_get_decimal128, @var{DECIMAL128_VAR} @var{MPFR_OP} @var{MPFR_RND}}

@deffn Builtin mpfr_get_z @var{MPZ_ROP} @var{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_get_z}.
@end deffn


@deffn Builtin mpfr_get_q @var{MPQ_ROP} @var{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_get_q}.
@end deffn


@deffn Builtin mpfr_get_f @var{MPF_ROP} @var{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_get_f}.
@end deffn

@c ------------------------------------------------------------------------

@deffn Builtin mpfr_get_d_2exp @var{MANTISSA_VAR} @var{EXPONENT_VAR} @var{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_get_d_2exp}.

@example
declare MAN EXP OP

mpfr_alloc_and_init OP
@{
    mpfr_set_d @WW{OP} '1.23' @WW{MPFR_RNDN}
    mpfr_get_si VAL @WW{OP} @WW{MPFR_RNDN}

    mmux_double_set_format "%f"
    mpfr_get_d_2exp MAN EXP @WW{OP} @WW{MPFR_RNDN}
@}
mpfr_clear_and_free @WW{OP}

@WW{MAN}        @result{} 0.615000
@WW{EXP}        @result{} 1
@end example
@end deffn


@deffn Builtin mpfr_get_ld_2exp @var{MANTISSA_VAR} @var{EXPONENT_VAR} @var{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_get_ld_2exp}.
@end deffn


@deffn Builtin mpfr_get_z_2exp @var{EXPONENT_VAR} @var{MPZ_ROP} @var{MPFR_OP}
Interface to the C language function @cfunc{mpfr_get_z_2exp}.
@end deffn

@c ------------------------------------------------------------------------

@deffn Builtin mpfr_frexp @var{EXPONENT_VAR} @vari{MPFR_OP} @varii{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_frexp}.

@example
declare -a OPS

mpfr_alloc_and_init_shell_array OPS
@{
    declare -n X='OPS[0]' Y='OPS[1]'
    declare EXP

    mpfr_set_d @WW{OP} '1.23' @WW{MPFR_RNDN}

    mpfr_frexp EXP @WW{Y} @WW{X} @WW{MPFR_RNDN}

    printf '%s\n' @WW{EXP}              @print{} 1
    mpfr_just_printit_dammit @WW{Y}     @print{} 0.615000e0
@}
mpfr_clear_and_free_shell_array OPS
@end example
@end deffn


@c ------------------------------------------------------------------------

@deffn Builtin mpfr_get_str @var{MANTISSA_VAR} @var{EXPONENT_VAR} @var{BASE} @var{NDIGITS} @var{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_get_str}.

The argument @var{MANTISSA_VAR} must be a string representing a shell variable name; when
successful, this function stores a string representation of the mantissa in this variable; if an
error occurs, the variable is left untouched, unless there is an error setting the result variables
themselves.

The argument @var{EXPONENT_VAR} must be a string representing a shell variable name; when
successful, this function stores a string representation of the exponent in this variable; if an
error occurs, the variable is left untouched, unless there is an error setting the result variables
themselves.

@example
declare -ri BASE=10 NDIGITS=0
declare OP MAN EXP

mpfr_alloc_and_init OP
@{
    mpfr_set_d @WW{OP} '1.23' @WW{MPFR_RNDN}
    mpfr_get_str MAN EXP @WW{BASE} @WW{NDIGITS} @WW{OP} @WW{MPFR_RNDN}
@}
mpfr_clear_and_free @WW{OP}

@WW{MAN}            @result{} 12300000000000000
@WW{EXP}            @result{} 1
@end example
@end deffn

@c ------------------------------------------------------------------------

@macro MmuxMpfrDefineFitser{STEM}
@deffn Builtin mpfr_fits_\STEM\_p @var{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_fits_\STEM\_p}.  This function also returns true
when the call is successful and false if an error occurs.  To check if @var{MPFR_OP} fits the
specified type: we have to examine the shell variable @env{MPFR_RV}, which is set to: @samp{1} if
the number fits; @samp{0} if the number does not fit.
@end deffn

@end macro

@MmuxMpfrDefineFitser{sshort}
@MmuxMpfrDefineFitser{ushort}
@MmuxMpfrDefineFitser{sint}
@MmuxMpfrDefineFitser{uint}
@MmuxMpfrDefineFitser{slong}
@MmuxMpfrDefineFitser{ulong}
@MmuxMpfrDefineFitser{intmax}
@MmuxMpfrDefineFitser{uintmax}

@c ------------------------------------------------------------------------

@deffn Builtin mpfr_get_str_ndigits @var{SIZE_VAR} @var{BASE} @var{PREC}
Interface to the C language function @cfunc{mpfr_get_str_ndigits}.

@example
declare -ri BASE=10 PREC=7
declare SIZE

mpfr_get_str_ndigits SIZE @WW{BASE} @WW{PREC}
@WW{SIZE}       @result{} 4
@end example
@end deffn

@c page
@node arithmetic
@chapter Arithmetic builtins


To compute the sum between @mpfr{} numbers, we do:

@example
declare -a OPS

mpfr_alloc_and_init_shell_array OPS 3
@{
    declare -n ROP='OPS[0]' OP1='OPS[1]' OP2='OPS[02]'

    mpfr_set_si @WW{OP1} '123' @WW{MPFR_RNDN}
    mpfr_set_si @WW{OP2} '456' @WW{MPFR_RNDN}

    mpfr_add @WW{ROP} @WW{OP1} @WW{OP2} @WW{MPFR_RNDN}

    mpfr_just_printit_dammit @WW{ROP}   @print{} 0.579000e3
@}
mpfr_clear_and_free_shell_array OPS
@end example

@menu
* arithmetic addition::         Addition builtins.
* arithmetic multiplication::   Multiplication builtins.
* arithmetic subtraction::      Subtraction builtins.
* arithmetic division::         Division builtins.
* arithmetic powers::           Powers and roots builtins.
* arithmetic misc::             Miscellaneous builtins.
@end menu

@c page
@node arithmetic addition
@section Addition builtins


@ref{overview conventions, Conventions used in this documentation}.


@deffn Builtin mpfr_add @var{MPFR_ROP} @vari{MPFR_OP} @varii{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_add}.
@end deffn


@deffn Builtin mpfr_add_si @var{MPFR_ROP} @var{MPFR_OP} @var{SLONG} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_add_si}.
@end deffn


@deffn Builtin mpfr_add_ui @var{MPFR_ROP} @var{MPFR_OP} @var{ULONG} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_add_ui}.
@end deffn


@deffn Builtin mpfr_add_d @var{MPFR_ROP} @var{MPFR_OP} @var{DOUBLE} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_add_d}.
@end deffn


@deffn Builtin mpfr_add_z @var{MPFR_ROP} @var{MPFR_OP} @var{MPZ_PTR} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_add_z}.
@end deffn


@deffn Builtin mpfr_add_q @var{MPFR_ROP} @var{MPFR_OP} @var{MPQ_PTR} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_add_q}.
@end deffn

@c page
@node arithmetic multiplication
@section Multiplication builtins


@ref{overview conventions, Conventions used in this documentation}.


@deffn Builtin mpfr_mul @var{MPFR_ROP} @vari{MPFR_OP} @varii{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_mul}.
@end deffn


@deffn Builtin mpfr_mul_si @var{MPFR_ROP} @var{MPFR_OP} @var{SLONG} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_mul_si}.
@end deffn


@deffn Builtin mpfr_mul_ui @var{MPFR_ROP} @var{MPFR_OP} @var{ULONG} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_mul_ui}.
@end deffn


@deffn Builtin mpfr_mul_d @var{MPFR_ROP} @var{MPFR_OP} @var{DOUBLE} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_mul_d}.
@end deffn


@deffn Builtin mpfr_mul_z @var{MPFR_ROP} @var{MPFR_OP} @var{MPZ_PTR} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_mul_z}.
@end deffn


@deffn Builtin mpfr_mul_q @var{MPFR_ROP} @var{MPFR_OP} @var{MPQ_PTR} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_mul_q}.
@end deffn


@deffn Builtin mpfr_mul_2si @var{MPFR_ROP} @var{MPFR_OP} @var{SLONG} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_mul_2si}.

@example
declare -a OPS

mpfr_alloc_and_init_shell_array OPS 3
@{
    declare -n ROP='OPS[0]' OP1='OPS[1]'
    declare OP2=3

    mpfr_set_si @WW{OP1} '5' @WW{MPFR_RNDN}

    mpfr_mul_2si @WW{ROP} @WW{OP1} @WW{OP2} @WW{MPFR_RNDN}

    # 5 * 2^3 = 5 * 8 = 40
    mpfr_just_printit_dammit @WW{ROP}   @print{} 0.400000e2
@}
mpfr_clear_and_free_shell_array OPS
@end example
@end deffn


@deffn Builtin mpfr_mul_2ui @var{MPFR_ROP} @var{MPFR_OP} @var{ULONG} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_mul_2ui}.
@end deffn

@c page
@node arithmetic subtraction
@section Subtraction builtins


@ref{overview conventions, Conventions used in this documentation}.


@deffn Builtin mpfr_sub @var{MPFR_ROP} @vari{MPFR_OP} @varii{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_sub}.
@end deffn


@deffn Builtin mpfr_sub_si @var{MPFR_ROP} @var{MPFR_OP} @var{SLONG} @var{MPFR_RND}
@deffnx Builtin mpfr_si_sub @var{MPFR_ROP} @var{SLONG} @var{MPFR_OP} @var{MPFR_RND}
Interfaces to the C language functions @cfunc{mpfr_sub_si}, @cfunc{mpfr_si_sub}.
@end deffn


@deffn Builtin mpfr_sub_ui @var{MPFR_ROP} @var{MPFR_OP} @var{ULONG} @var{MPFR_RND}
@deffnx Builtin mpfr_ui_sub @var{MPFR_ROP} @var{ULONG} @var{MPFR_OP} @var{MPFR_RND}
Interfaces to the C language functions @cfunc{mpfr_sub_ui}, @cfunc{mpfr_ui_sub}.
@end deffn


@deffn Builtin mpfr_sub_d @var{MPFR_ROP} @var{MPFR_OP} @var{DOUBLE} @var{MPFR_RND}
@deffnx Builtin mpfr_d_sub @var{MPFR_ROP} @var{DOUBLE} @var{MPFR_OP} @var{MPFR_RND}
Interfaces to the C language functions @cfunc{mpfr_sub_d}, @cfunc{mpfr_d_sub}.
@end deffn


@deffn Builtin mpfr_sub_z @var{MPFR_ROP} @var{MPFR_OP} @var{MPZ_PTR} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_sub_z}.
@end deffn


@deffn Builtin mpfr_sub_q @var{MPFR_ROP} @var{MPFR_OP} @var{MPQ_PTR} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_sub_q}.
@end deffn

@c page
@node arithmetic division
@section Division builtins


@ref{overview conventions, Conventions used in this documentation}.


@deffn Builtin mpfr_div @var{MPFR_ROP} @vari{MPFR_OP} @varii{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_div}.
@end deffn


@deffn Builtin mpfr_div_si @var{MPFR_ROP} @var{MPFR_OP} @var{SLONG} @var{MPFR_RND}
@deffnx Builtin mpfr_si_div @var{MPFR_ROP} @var{SLONG} @var{MPFR_OP} @var{MPFR_RND}
Interfaces to the C language functions @cfunc{mpfr_div_si}, @cfunc{mpfr_si_div}.
@end deffn


@deffn Builtin mpfr_div_ui @var{MPFR_ROP} @var{MPFR_OP} @var{ULONG} @var{MPFR_RND}
@deffnx Builtin mpfr_ui_div @var{MPFR_ROP} @var{ULONG} @var{MPFR_OP} @var{MPFR_RND}
Interfaces to the C language functions @cfunc{mpfr_div_ui}, @cfunc{mpfr_ui_div}.
@end deffn


@deffn Builtin mpfr_div_d @var{MPFR_ROP} @var{MPFR_OP} @var{DOUBLE} @var{MPFR_RND}
@deffnx Builtin mpfr_d_div @var{MPFR_ROP} @var{DOUBLE} @var{MPFR_OP} @var{MPFR_RND}
Interfaces to the C language functions @cfunc{mpfr_div_d}, @cfunc{mpfr_d_div}.
@end deffn


@deffn Builtin mpfr_div_z @var{MPFR_ROP} @var{MPFR_OP} @var{MPZ_PTR} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_div_z}.
@end deffn


@deffn Builtin mpfr_div_q @var{MPFR_ROP} @var{MPFR_OP} @var{MPQ_PTR} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_div_q}.
@end deffn


@deffn Builtin mpfr_div_2si @var{MPFR_ROP} @var{MPFR_OP} @var{SLONG} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_div_2si}.

@example
declare -a OPS

mpfr_alloc_and_init_shell_array OPS 3
@{
    declare -n ROP='OPS[0]' OP1='OPS[1]'
    declare OP2=3

    mpfr_set_si @WW{OP1} '40' @WW{MPFR_RNDN}

    mpfr_div_2si @WW{ROP} @WW{OP1} @WW{OP2} @WW{MPFR_RNDN}

    # 40 / 2^3 = 40 / 8 = 5
    mpfr_just_printit_dammit @WW{ROP}   @print{} 0.500000e1
@}
mpfr_clear_and_free_shell_array OPS
@end example
@end deffn


@deffn Builtin mpfr_div_2ui @var{MPFR_ROP} @var{MPFR_OP} @var{ULONG} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_div_2ui}.
@end deffn

@c page
@node arithmetic powers
@section Powers and roots builtins


@ref{overview conventions, Conventions used in this documentation}.


@deffn Builtin mpfr_sqr @var{MPFR_ROP} @var{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_sqr}.
@end deffn


@deffn Builtin mpfr_sqrt @var{MPFR_ROP} @var{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_sqrt}.
@end deffn


@deffn Builtin mpfr_sqrt_ui @var{MPFR_ROP} @var{ULONG} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_sqrt_ui}.
@end deffn


@deffn Builtin mpfr_rec_sqrt @var{MPFR_ROP} @var{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_rec_sqrt}.

@example
declare OPS

mpfr_alloc_and_init_shell_array OPS 2
@{
    declare -n ROP='OPS[0]' OP='OPS[1]'

    mpfr_set_si @WW{OP} 100 @WW{MPFR_RNDN}
    mpfr_rec_sqrt @WW{ROP} @WW{OP} @WW{MPFR_RNDN}

    # 1 / sqrt(100) = 1 / 10 = 0.1
    mpfr_just_printit_dammit @WW{ROP}   @print{} 0.100000e0
@}
mpfr_clear_and_free_shell_array OPS
@end example
@end deffn


@deffn Builtin mpfr_cbrt @var{MPFR_ROP} @var{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_cbrt}.
@end deffn


@deffn Builtin mpfr_rootn_si @var{MPFR_ROP} @var{MPFR_OP} @var{SLONG_N} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_rootn_si}.
@end deffn


@deffn Builtin mpfr_rootn_ui @var{MPFR_ROP} @var{MPFR_OP} @var{ULONG_N} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_rootn_ui}.
@end deffn

@c page
@node arithmetic misc
@section Miscellaneous builtins


@ref{overview conventions, Conventions used in this documentation}.


@deffn Builtin mpfr_neg @var{MPFR_ROP} @var{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_neg}.
@end deffn


@deffn Builtin mpfr_abs @var{MPFR_ROP} @var{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_abs}.
@end deffn


@deffn Builtin mpfr_dim @var{MPFR_ROP} @vari{MPFR_OP} @varii{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_dim}.
@end deffn


@deffn Builtin mpfr_fac_ui @var{MPFR_ROP} @var{ULONG} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_fac_ui}.
@end deffn


@deffn Builtin mpfr_fma @var{MPFR_ROP} @vari{MPFR_OP} @varii{MPFR_OP} @variii{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_fma}.

@example
declare -a OPS

mpfr_alloc_and_init_shell_array OPS 4
@{
    declare -n ROP='OPS[0]' OP1='OPS[1]' OP2='OPS[2]' OP3='OPS[3]'

    mpfr_set_si @WW{OP1} 11 @WW{MPFR_RNDN}
    mpfr_set_si @WW{OP2} 22 @WW{MPFR_RNDN}
    mpfr_set_si @WW{OP3} 33 @WW{MPFR_RNDN}

    # (11 * 22) + 33
    mpfr_fma @WW{ROP} @WW{OP1} @WW{OP2} @WW{OP3} @WW{MPFR_RNDN}

    mpfr_just_printit_dammit @WW{ROP}   @print{} 0.275000e3
@}
mpfr_clear_and_free_shell_array OPS
@end example
@end deffn


@deffn Builtin mpfr_fms @var{MPFR_ROP} @vari{MPFR_OP} @varii{MPFR_OP} @variii{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_fms}.
@end deffn


@deffn Builtin mpfr_fmma @var{MPFR_ROP} @vari{MPFR_OP} @varii{MPFR_OP} @variii{MPFR_OP} @variv{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_fmma}.
@end deffn


@deffn Builtin mpfr_fmms @var{MPFR_ROP} @vari{MPFR_OP} @varii{MPFR_OP} @variii{MPFR_OP} @variv{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_fmms}.
@end deffn


@deffn Builtin mpfr_hypot @var{MPFR_ROP} @vari{MPFR_OP} @varii{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_hypot}.
@end deffn


@deffn Builtin mpfr_sum @var{MPFR_ROP} @var{MPFR_PTR_ARRAY} @var{ULONG_DIM} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_sum}.

The argument @var{MPFR_PTR_ARRAY} must be a pointer to an array of pointers, each of which
references a @mpfr{} number.

The argument @var{ULONG_DIM} must be the number of slots in the array of pointers.

@example
declare -a OPS
declare -i DIM=5
declare POINTERS

mpfr_alloc_and_init_shell_array OPS @WW{DIM}
@{
    mpfr_alloc_and_init_pointers_array POINTERS OPS
    @{
        mpfr_alloc_and_init ROP
        @{
            mpfr_set_si $@{OPS[0]:?@} 11 @WW{MPFR_RNDN}
            mpfr_set_si $@{OPS[1]:?@} 22 @WW{MPFR_RNDN}
            mpfr_set_si $@{OPS[2]:?@} 33 @WW{MPFR_RNDN}
            mpfr_set_si $@{OPS[3]:?@} 44 @WW{MPFR_RNDN}
            mpfr_set_si $@{OPS[4]:?@} 55 @WW{MPFR_RNDN}

            mpfr_sum @WW{ROP} @WW{POINTERS} @WW{DIM} @WW{MPFR_RNDN}

            mpfr_just_printit_dammit @WW{ROP}
        @}
        mpfr_clear_and_free @WW{ROP}
    @}
    mmux_libc_free @WW{POINTERS}
@}
mpfr_clear_and_free_shell_array OPS
@end example
@end deffn


@deffn Builtin mpfr_dot @var{MPFR_ROP} @vari{MPFR_PTR_ARRAY} @varii{MPFR_PTR_ARRAY} @var{ULONG_DIM} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_dot}.

The arguments @vari{MPFR_PTR_ARRAY} and @varii{MPFR_PTR_ARRAY} must be a pointers to an arrays of
pointers, each of which references a @mpfr{} number.

The argument @var{ULONG_DIM} must be the number of slots in the arrays of pointers.

@example
declare -a OPS1 OPS2
declare -i DIM=5
declare POINTERS1 POINTERS2

mpfr_alloc_and_init_shell_array OPS1 @WW{DIM}
mpfr_alloc_and_init_shell_array OPS2 @WW{DIM}
@{
    mpfr_alloc_and_init_pointers_array POINTERS1 OPS1
    mpfr_alloc_and_init_pointers_array POINTERS2 OPS2
    @{
        mpfr_alloc_and_init ROP
        @{
            mpfr_set_si $@{OPS1[0]:?@} 11 @WW{MPFR_RNDN}
            mpfr_set_si $@{OPS1[1]:?@} 22 @WW{MPFR_RNDN}
            mpfr_set_si $@{OPS1[2]:?@} 33 @WW{MPFR_RNDN}
            mpfr_set_si $@{OPS1[3]:?@} 44 @WW{MPFR_RNDN}
            mpfr_set_si $@{OPS1[4]:?@} 55 @WW{MPFR_RNDN}

            mpfr_set_si $@{OPS2[0]:?@} 66 @WW{MPFR_RNDN}
            mpfr_set_si $@{OPS2[1]:?@} 77 @WW{MPFR_RNDN}
            mpfr_set_si $@{OPS2[2]:?@} 88 @WW{MPFR_RNDN}
            mpfr_set_si $@{OPS2[3]:?@} 99 @WW{MPFR_RNDN}
            mpfr_set_si $@{OPS2[4]:?@} 10 @WW{MPFR_RNDN}

            mpfr_dot @WW{ROP} @WW{POINTERS1} @WW{POINTERS2} @WW{DIM} @WW{MPFR_RNDN}

            mpfr_just_printit_dammit @WW{ROP}
        @}
        mpfr_clear_and_free @WW{ROP}
    @}
    mmux_libc_free @WW{POINTERS2}
    mmux_libc_free @WW{POINTERS1}
@}
mpfr_clear_and_free_shell_array OPS2
mpfr_clear_and_free_shell_array OPS1
@end example
@end deffn

@c page
@node comparison
@chapter Comparison builtins


@menu
* comparison ternary::          Comparison builtins.
* comparison predicates::       Comparison predicates.
* comparison order::            Comparison to order.
* comparison approximate::      Approximate comparison.
@end menu

@c page
@node comparison ternary
@section Comparison builtins


@ref{overview conventions, Conventions used in this documentation}.


@defun Builtin mpfr_cmp @vari{MPFR_OP} @varii{MPFR_OP}
@defunx Builtin mpfr_cmp_si @vari{MPFR_OP} @varii{SLONG}
@defunx Builtin mpfr_cmp_ui @vari{MPFR_OP} @varii{ULONG}
@defunx Builtin mpfr_cmp_d @vari{MPFR_OP} @varii{DOUBLE}
@defunx Builtin mpfr_cmp_ld @vari{MPFR_OP} @varii{LDOUBLE}
@defunx Builtin mpfr_cmp_z @vari{MPFR_OP} @varii{MPZ_OP}
@defunx Builtin mpfr_cmp_q @vari{MPFR_OP} @varii{MPQ_OP}
@defunx Builtin mpfr_cmp_f @vari{MPFR_OP} @varii{MPF_OP}
Interfaces to the C language functions @cfunc{mpfr_cmp}, @cfunc{mpfr_cmp_si}, @cfunc{mpfr_cmp_ui},
@cfunc{mpfr_cmp_d}, @cfunc{mpfr_cmp_ld}, @cfunc{mpfr_cmp_z}, @cfunc{mpfr_cmp_q}, @cfunc{mpfr_cmp_f}.
When successful return true; otherwise return false.  To inspect the comparison result we have to
use the shell variable @env{MPFR_RV}.

@example
declare OPS

mpfr_alloc_and_init_shell_array OPS 2
@{
    declare -n OP1='OPS[0]' OP2='OPS[1]'

    mpfr_set_si @WW{OP1} 123 @WW{MPFR_RNDN}
    mpfr_set_si @WW{OP2} 456 @WW{MPFR_RNDN}

    mpfr_cmp @WW{OP1} @WW{OP2}

    if (( MPFR_RV < 0 ))
    then # OP1 <  OP2
    else # OP1 >= OP2
    fi
@}
mpfr_clear_and_free_shell_array @WW{OPS}
@end example
@end defun


@defun Builtin mpfr_cmp_si_2exp @vari{MPFR_OP} @varii{SLONG} @var{MPFR_EXP}
@defunx Builtin mpfr_cmp_ui_2exp @vari{MPFR_OP} @varii{ULONG} @var{MPFR_EXP}
Interfaces to the C language functions @cfunc{mpfr_cmp_si_2exp}, @cfunc{mpfr_cmp_ui_2exp}.

@example
declare OP1 OP2=100 EXPON=3

mpfr_alloc_and_init OP1
@{
    mpfr_set_si @WW{OP} 800 @WW{MPFR_RNDN}

    mpfr_cmp_si_2exp @WW{OP1} @WW{OP2} @WW{EXPON}

    if (( 0 == MPFR_RV ))
    then # OP1 == OP2 * 2^EXPON
    else # otherwise
    fi
@}
mpfr_clear_and_free @WW{OP1}
@end example
@end defun

@c page
@node comparison predicates
@section Comparison predicates


@ref{overview conventions, Conventions used in this documentation}.


@deffn Builtin mpfr_nan_p @var{MPFR_OP}
Interface to the C language function @cfunc{mpfr_nan_p}.  When successful return true; otherwise
return false.  To inspect the predicate result we have to use the shell variable @env{MPFR_RV}.

@example
declare OP
declare -i MPFR_RV

mpfr_alloc_and_init OP
@{
    mpfr_set_si @WW{OP} '123' @WW{MPFR_RNDN}

    mpfr_nan_p @WW{OP}

    if (( 1 == MPFR_RV ))
    then # it is nan
    else # it is not nan
    fi
@}
mpfr_clear_and_free @WW{OP}
@end example
@end deffn


@macro MmuxBashMpfrDefineComparisonPredicate{NAME}
@deffn Builtin \NAME\ @var{MPFR_OP}
Interface to the C language function @cfunc{\NAME\}.  When successful return true; otherwise return
false.  To inspect the predicate result we have to use the shell variable @env{MPFR_RV}.
@end deffn

@end macro

@MmuxBashMpfrDefineComparisonPredicate{mpfr_inf_p}
@MmuxBashMpfrDefineComparisonPredicate{mpfr_number_p}
@MmuxBashMpfrDefineComparisonPredicate{mpfr_zero_p}
@MmuxBashMpfrDefineComparisonPredicate{mpfr_regular_p}

@c page
@node comparison order
@section Comparison to order


@ref{overview conventions, Conventions used in this documentation}.


@deffn Builtin mpfr_greater_p @vari{MPFR_OP} @varii{MPFR_OP}
@deffnx Builtin mpfr_greaterequal_p @vari{MPFR_OP} @varii{MPFR_OP}
@deffnx Builtin mpfr_less_p @vari{MPFR_OP} @varii{MPFR_OP}
@deffnx Builtin mpfr_lessequal_p @vari{MPFR_OP} @varii{MPFR_OP}
@deffnx Builtin mpfr_equal_p @vari{MPFR_OP} @varii{MPFR_OP}
@deffnx Builtin mpfr_lessgreater_p @vari{MPFR_OP} @varii{MPFR_OP}
@deffnx Builtin mpfr_unordered_p @vari{MPFR_OP} @varii{MPFR_OP}
@deffnx Builtin mpfr_total_order_p @vari{MPFR_OP} @varii{MPFR_OP}
Interfaces to the C language functions @cfunc{mpfr_greater_p}, @cfunc{mpfr_greaterequal_p},
@cfunc{mpfr_less_p}, @cfunc{mpfr_lessequal_p}, @cfunc{mpfr_equal_p}, @cfunc{mpfr_lessgreater_p},
@cfunc{mpfr_unordered_p}, @cfunc{mpfr_total_order_p}.  When successful return true; otherwise return
false.  To inspect the predicate result we have to use the shell variable @env{MPFR_RV}.

@example
declare OPS

mpfr_alloc_and_init_shell_array OPS 2
@{
    declare -n OP1='OPS[0]' OP2='OPS[1]'

    mpfr_set_si @WW{OP1} 123 @WW{MPFR_RNDN}
    mpfr_set_si @WW{OP2} 456 @WW{MPFR_RNDN}

    mpfr_equal_p @WW{OP1} @WW{OP2}

    if (( 1 == MPFR_RV ))
    then # OP1 == OP2
    else # OP1 != OP2
    fi
@}
mpfr_clear_and_free_shell_array @WW{OPS}
@end example
@end deffn


@MmuxDefineBinaryBuiltin{mpfr_min}
@MmuxDefineBinaryBuiltin{mpfr_max}

@c page
@node comparison approximate
@section Approximate comparison


@menu
* comparison approximate absmargin::     Absolute margin criterion.
* comparison approximate relepsilon::    Relative epsilon criterion.
@end menu

@c page
@node comparison approximate absmargin
@subsection Absolute margin criterion


To compare two @mpfr{} numbers with the criterion of the absolute margin, we do:

@example
declare OPS

mpfr_alloc_and_init_shell_array OPS 2
@{
    declare -n OP1='OPS[0]' OP2='OPS[1]'
    declare -r ABSOLUTE_MARGIN_MPFR='0.1'
    declare -i MPFR_RV

    mpfr_set_d @WW{OP1} '1.0'  @WW{MPFR_RNDN}
    mpfr_set_d @WW{OP2} '1.02' @WW{MPFR_RNDN}

    mpfr_equal_absmargin @WW{OP1} @WW{OP2}

    if (( 1 == MPFR_RV ))
    then # approximately equal
    else # different
    fi
@}
mpfr_clear_and_free_shell_array OPS
@end example

@ref{overview conventions, Conventions used in this documentation}.


@deffn Builtin mpfr_equal_absmargin @vari{OP} @varii{OP}
Compare the operands with the absolute margin criterion.  When successful return true; otherwise
return false.  To inspect the predicate result we have to use the shell variable
@env{MPFR_RV}.

The comparison predicate is:

@example
abs(@vari{OP} - @varii{OP}) <= abs(@var{MARGIN})
@end example

@noindent
where @var{MARGIN} is an @mpfr{} number initialised with the value in the shell variable
@env{ABSOLUTE_MARGIN_MPFR}.
@end deffn


@defvar ABSOLUTE_MARGIN_MPFR
Shell variable used to select the margin for the equality with the absolute margin criterion.  The
variable must hold the string representation of a real number parsable with @cfunc{mpfr_set_str}
called with base argument set to @samp{0}.

When the shell variable is not set: the default value is @samp{1e-6}.
@end defvar

@c page
@node comparison approximate relepsilon
@subsection Relative epsilon criterion


To compare two @mpfr{} numbers with the criterion of the relative epsilon, we do:

@example
declare OPS

mpfr_alloc_and_init_shell_array OPS 2
@{
    declare -r RELATIVE_EPSILON_MPFR='0.1'
    declare -i MPFR_RV
    declare -n OP1='OPS[0]' OP2='OPS[1]'

    mpfr_set_d @WW{OP1} '1.0'  @WW{MPFR_RNDN}
    mpfr_set_d @WW{OP2} '1.02' @WW{MPFR_RNDN}

    mpfr_equal_relepsilon @WW{OP1} @WW{OP2}

    if (( 1 == MPFR_RV ))
    then # approximately equal
    else # different
    fi
@}
mpfr_clear_and_free_shell_array OPS
@end example


@ref{overview conventions, Conventions used in this documentation}.


@deffn Builtin mpfr_equal_relepsilon @vari{OP} @varii{OP}
Compare the operands with the relative epsilon criterion.  When successful return true; otherwise
return false.  To inspect the predicate result we have to use the shell variable @env{MPFR_RV}.

The comparison predicate is:

@example
abs(@vari{OP} - @varii{OP}) <= (@var{EPSILON} * max(abs(@vari{OP}), abs(@varii{OP})))
@end example

@noindent
where @var{EPSILON} is an @mpfr{} number initialised with the value in the shell variable
@env{RELATIVE_EPSILON_MPFR}.
@end deffn


@defvar RELATIVE_EPSILON_MPFR
Shell variable used to select the epsilon for the equality with the relative epsilon criterion.  The
variable must hold the string representation of a real number parsable with @cfunc{mpfr_set_str}
called with base argument set to @samp{0}.

When the shell variable is not set: the default value is @samp{1e-6}.
@end defvar

@c page
@node transcendental
@chapter Transcendental builtins


@menu
* transcendental logarithms::           Builtins for logarithms.
* transcendental exponentiation::       Builtins for exponentiation.
* transcendental trigonometric::        Builtins for trigonometric operations.
* transcendental hyperbolic::           Builtins for hyperbolic operations.
* transcendental special::              Builtins special operations.
* transcendental constants::            Builtins for constant values.
@end menu

@c page
@node transcendental logarithms
@section Builtins for logarithms


@ref{overview conventions, Conventions used in this documentation}.


@MmuxDefineUnaryBuiltin{mpfr_log}
@MmuxDefineUnaryUiBuiltin{mpfr_log_ui}
@MmuxDefineUnaryBuiltin{mpfr_log2}
@MmuxDefineUnaryBuiltin{mpfr_log10}
@MmuxDefineUnaryBuiltin{mpfr_log1p}
@MmuxDefineUnaryBuiltin{mpfr_log2p1}
@MmuxDefineUnaryBuiltin{mpfr_log10p1}

@c page
@node transcendental exponentiation
@section Builtins for exponentiation


@ref{overview conventions, Conventions used in this documentation}.


@MmuxDefineUnaryBuiltin{mpfr_exp}
@MmuxDefineUnaryBuiltin{mpfr_exp2}
@MmuxDefineUnaryBuiltin{mpfr_exp10}
@MmuxDefineUnaryBuiltin{mpfr_expm1}
@MmuxDefineUnaryBuiltin{mpfr_exp2m1}
@MmuxDefineUnaryBuiltin{mpfr_exp10m1}

@MmuxDefineBinaryBuiltin{mpfr_pow}
@MmuxDefineBinaryBuiltin{mpfr_powr}
@MmuxDefineBinarySiBuiltin{mpfr_pow_si}
@MmuxDefineBinaryUiBuiltin{mpfr_pow_ui}
@MmuxDefineBinarySjBuiltin{mpfr_pow_sj}
@MmuxDefineBinaryUjBuiltin{mpfr_pow_uj}
@MmuxDefineBinaryZBuiltin{mpfr_pow_z}
@MmuxDefineUiBinaryUiBuiltin{mpfr_ui_pow_ui}
@MmuxDefineUiBinaryBuiltin{mpfr_ui_pow}

@MmuxDefineBinarySiBuiltin{mpfr_compound_si}

@c page
@node transcendental trigonometric
@section Builtins for trigonometric operations


@ref{overview conventions, Conventions used in this documentation}.


@MmuxDefineUnaryBuiltin{mpfr_sin}
@MmuxDefineUnaryBuiltin{mpfr_cos}
@MmuxDefineUnaryBuiltin{mpfr_tan}

@MmuxDefineUnaryBuiltin{mpfr_sinpi}
@MmuxDefineUnaryBuiltin{mpfr_cospi}
@MmuxDefineUnaryBuiltin{mpfr_tanpi}
@MmuxDefineBinaryBuiltin{mpfr_sin_cos}

@MmuxDefineUnaryBuiltin{mpfr_sec}
@MmuxDefineUnaryBuiltin{mpfr_csc}
@MmuxDefineUnaryBuiltin{mpfr_cot}

@MmuxDefineUnaryBuiltin{mpfr_asin}
@MmuxDefineUnaryBuiltin{mpfr_acos}
@MmuxDefineUnaryBuiltin{mpfr_atan}

@MmuxDefineBinaryUiBuiltin{mpfr_acosu}
@MmuxDefineBinaryUiBuiltin{mpfr_asinu}
@MmuxDefineBinaryUiBuiltin{mpfr_atanu}

@MmuxDefineUnaryBuiltin{mpfr_asinpi}
@MmuxDefineUnaryBuiltin{mpfr_acospi}
@MmuxDefineUnaryBuiltin{mpfr_atanpi}

@MmuxDefineBinaryBuiltin{mpfr_atan2}
@MmuxDefineTernaryUiBuiltin{mpfr_atan2u}
@MmuxDefineBinaryBuiltin{mpfr_atan2pi}

@c page
@node transcendental hyperbolic
@section Builtins for hyperbolic operations


@ref{overview conventions, Conventions used in this documentation}.


@MmuxDefineUnaryBuiltin{mpfr_sinh}
@MmuxDefineUnaryBuiltin{mpfr_cosh}
@MmuxDefineUnaryBuiltin{mpfr_tanh}
@MmuxDefineBinaryBuiltin{mpfr_sinh_cosh}

@MmuxDefineUnaryBuiltin{mpfr_sech}
@MmuxDefineUnaryBuiltin{mpfr_csch}
@MmuxDefineUnaryBuiltin{mpfr_coth}

@MmuxDefineUnaryBuiltin{mpfr_asinh}
@MmuxDefineUnaryBuiltin{mpfr_acosh}
@MmuxDefineUnaryBuiltin{mpfr_atanh}

@c page
@node transcendental special
@section Builtins special operations


@ref{overview conventions, Conventions used in this documentation}.


@MmuxDefineUnaryBuiltin{mpfr_eint}
@MmuxDefineUnaryBuiltin{mpfr_li2}
@MmuxDefineUnaryBuiltin{mpfr_gamma}
@MmuxDefineBinaryBuiltin{mpfr_gamma_inc}
@MmuxDefineUnaryBuiltin{mpfr_lngamma}
@MmuxDefineUnaryBuiltin{mpfr_digamma}

@deffn Builtin mpfr_lgamma @var{MPFR_ROP} @var{SIGNVAR} @var{MPFR_OP} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_lgamma}.

Store in the shell variable @var{SIGNVAR} the computed sign.
@end deffn

@MmuxDefineBinaryBuiltin{mpfr_beta}
@MmuxDefineUnaryBuiltin{mpfr_zeta}
@MmuxDefineUnaryUiBuiltin{mpfr_zeta_ui}
@MmuxDefineUnaryBuiltin{mpfr_erf}
@MmuxDefineUnaryBuiltin{mpfr_erfc}
@MmuxDefineUnaryBuiltin{mpfr_j0}
@MmuxDefineUnaryBuiltin{mpfr_j1}
@MmuxDefineSiBinaryBuiltin{mpfr_jn}
@MmuxDefineUnaryBuiltin{mpfr_y0}
@MmuxDefineUnaryBuiltin{mpfr_y1}
@MmuxDefineSiBinaryBuiltin{mpfr_yn}
@MmuxDefineBinaryBuiltin{mpfr_agm}
@MmuxDefineUnaryBuiltin{mpfr_ai}

@c page
@node transcendental constants
@section Builtins for constant values


@ref{overview conventions, Conventions used in this documentation}.


@MmuxDefineNullaryBuiltin{mpfr_const_log2}
@MmuxDefineNullaryBuiltin{mpfr_const_pi}
@MmuxDefineNullaryBuiltin{mpfr_const_euler}
@MmuxDefineNullaryBuiltin{mpfr_const_catalan}

@c page
@node io
@chapter Input, output, printing


@ref{overview conventions, Conventions used in this documentation}.


@deffn Builtin mpfr_dump @var{MPFR_PTR}
Interface to the C language function @cfunc{mpfr_dump}.

Printing an initialised but unset number:

@example
declare OP

mmux_libc_calloc OP 1 @WW{mpfr_SIZEOF}
mpfr_init @WW{OP}
mpfr_dump @WW{OP}   @print{} @@NaN@@
@end example

Printing an initialised and set number:

@example
declare OP

mmux_libc_calloc OP 1 @WW{mpfr_SIZEOF}
mpfr_init @WW{OP}
mpfr_set_d @WW{OP} '2.0'
mpfr_dump @WW{OP}
@print{} 0.10000000000000000000000000000000000000000000000000000E2
@end example
@end deffn


@defun mpfr_just_printit_dammit @var{MPFR_PTR}
Print to @stdout{} a string representation of @var{MPFR_PTR}, by default in base 10 with 6 digits;
the format is meant to resemble the standard @samp{%.6e}.

@example
declare OP

mmux_libc_calloc OP 1 @WW{mpfr_SIZEOF}
mpfr_init @WW{OP}
mpfr_set_d @WW{OP} '123.4567890' @WW{MPFR_RNDN}
mpfr_just_printit_dammit @WW{OP}
@print{} 0.123457e3
@end example
@end defun

@c page
@node integers
@chapter Integers builtins


@ref{overview conventions, Conventions used in this documentation}.


@MmuxDefineUnaryBuiltin{mpfr_rint}

@example
declare	-a OPS

mpfr_alloc_and_init_shell_array OPS 2
@{
    declare -n ROP='OPS[0]' OP='OPS[1]'

    mpfr_set_d @WW{OP} '123.456' @WW{MPFR_RNDN}
    mpfr_rint @WW{ROP} @WW{OP} @WW{MPFR_RNDN}

    mpfr_just_printit_dammit @WW{ROP}   @print{} 0.123000e3
@}
mpfr_clear_and_free_shell_array OPS
@end example

@MmuxDefineUnaryNorndBuiltin{mpfr_ceil}
@MmuxDefineUnaryNorndBuiltin{mpfr_floor}
@MmuxDefineUnaryNorndBuiltin{mpfr_round}
@MmuxDefineUnaryNorndBuiltin{mpfr_roundeven}
@MmuxDefineUnaryNorndBuiltin{mpfr_trunc}

@MmuxDefineUnaryBuiltin{mpfr_rint_ceil}
@MmuxDefineUnaryBuiltin{mpfr_rint_floor}
@MmuxDefineUnaryBuiltin{mpfr_rint_round}
@MmuxDefineUnaryBuiltin{mpfr_rint_roundeven}
@MmuxDefineUnaryBuiltin{mpfr_rint_trunc}

@MmuxDefineUnaryBuiltin{mpfr_frac}

@MmuxDefineUnaryBuiltin{mpfr_modf}
@MmuxDefineUnaryBuiltin{mpfr_fmod}
@MmuxDefineUnaryUiBuiltin{mpfr_fmod_ui}
@MmuxDefineUnaryBuiltin{mpfr_remainder}


@deffn Builtin mpfr_fmodquo @var{MPFR_R} @var{QVAR} @var{MPFR_X} @var{MPFR_Y} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_fmodquo}.

@example
declare -a OPS

mpfr_alloc_and_init_shell_array OPS 3
@{
    declare -n R='OPS[0]' X='OPS[1]' Y='OPS[2]'

    mpfr_set_d @WW{X} '123' @WW{MPFR_RNDN}
    mpfr_set_d @WW{Y}   '6' @WW{MPFR_RNDN}

    mpfr_fmodquo @WW{R} Q @WW{X} @WW{Y} @WW{MPFR_RNDN}

    mpfr_just_printit_dammit @WW{R}     @print{} 0.300000e1
    printf 'Q=%s\n' @WW{Q}              @print{} Q=20
@}
mpfr_clear_and_free_shell_array OPS
@end example
@end deffn


@deffn Builtin mpfr_remquo @var{MPFR_R} @var{QVAR} @var{MPFR_X} @var{MPFR_Y} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_fmodquo}.
@end deffn


@deffn Builtin mmux_integer_p @var{OP}
Interface to the C language function @cfunc{mpfr_integer_p}.  When successful return true; otherwise
return false.  To inspect the predicate result we have to use the shell variable @env{MPFR_RV}.

@example
declare OP
declare -i MPFR_RV

mpfr_alloc_and_init OP
@{
    mpfr_set_si @WW{OP} '123' @WW{MPFR_RNDN}

    mpfr_integer_p @WW{OP}

    if (( 1 == MPFR_RV ))
    then # it's an integer
    else # it is something else
    fi
@}
mpfr_clear_and_free @WW{OP}
@end example
@end deffn

@c page
@node rounding
@chapter Rounding--related builtins


@ref{overview conventions, Conventions used in this documentation}.


@deffn Builtin mpfr_set_default_rounding_mode @var{MPFR_RND}
@deffnx Builtin mpfr_get_default_rounding_mode @var{MPFR_RNDVAR}
Interfaces to the C language functions @cfunc{mpfr_set_default_rounding_mode},
@cfunc{mpfr_get_default_rounding_mode}.

@example
declare RND

mpfr_set_default_rounding_mode @WW{MPFR_RNDZ}
mpfr_get_default_rounding_mode RND
@WW{RND}  @result{} [whatever MPFR_RNDZ is]
@end example
@end deffn


@deffn Builtin mpfr_prec_round @var{MPFR_OP} @var{MPFR_PREC} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_prec_round}.
@end deffn


@deffn Builtin mpfr_can_round @var{MPFR_B} @var{MPFR_PREC} @vari{MPFR_RND} @varii{MPFR_RND}
Interface to the C language function @cfunc{mpfr_can_round}.
@end deffn


@deffn Builtin mpfr_min_prec @var{MPFR_PRECVAR} @var{OP}
Interface to the C language function @cfunc{mpfr_min_prec}.

@example
declare OP PREC

mpfr_alloc_and_init OP
@{
    mpfr_set_si @WW{OP} 1 @WW{MPFR_RNDN}

    mpfr_min_prec PREC @WW{OP}
    @WW{PREC}   @result{} 1
@}
mpfr_clear_and_free @WW{OP}
@end example
@end deffn


@deffn Builtin mpfr_print_rnd_mode @var{STRVAR} @var{MPFR_RND}
interface to the C language function @cfunc{mpfr_print_rnd_mode}.
@end deffn

@c page
@node stepping
@chapter Stepping builtins


@ref{overview conventions, Conventions used in this documentation}.


@deffn Builtin mpfr_nexttoward @vari{MPFR_OP} @varii{MPFR_OP}
Interface to the C language function @cfunc{mpfr_nexttoward}.

@example
declare -a OPS

mpfr_alloc_and_init_shell_array OPS 2
@{
    declare -n OP1='OPS[0]' OP2='OPS[1]'

    mpfr_set_prec @WW{OP1} 1
    mpfr_set_si @WW{OP1} 1 @WW{MPFR_RNDN}
    mpfr_set_si @WW{OP2} 3 @WW{MPFR_RNDN}
    mpfr_nexttoward @WW{OP1} @WW{OP2}

    mpfr_just_printit_dammit @WW{OP1}   @print{} 0.200000e1
@}
mpfr_clear_and_free_shell_array OPS
@end example

Stepping example:

@example
declare -a OPS

mpfr_alloc_and_init_shell_array OPS 2
@{
    declare -n OP1='OPS[0]' OP2='OPS[1]'

    mpfr_set_prec @WW{OP1} 3
    mpfr_set_si @WW{OP2} 3 @WW{MPFR_RNDN}

    mpfr_set_si @WW{OP1} 1 @WW{MPFR_RNDN}
    mpfr_just_printit_dammit @WW{OP1}   @print{} 0.100000e1

    mpfr_nexttoward @WW{OP1} @WW{OP2}
    mpfr_just_printit_dammit @WW{OP1}   @print{} 0.125000e1

    mpfr_nexttoward @WW{OP1} @WW{OP2}
    mpfr_just_printit_dammit @WW{OP1}   @print{} 0.150000e1

    mpfr_nexttoward @WW{OP1} @WW{OP2}
    mpfr_just_printit_dammit @WW{OP1}   @print{} 0.175000e1

    mpfr_nexttoward @WW{OP1} @WW{OP2}
    mpfr_just_printit_dammit @WW{OP1}   @print{} 0.200000e1
@}
mpfr_clear_and_free_shell_array OPS
@end example
@end deffn


@deffn Builtin mpfr_nextabove @var{MPFR_OP}
@deffnx Builtin mpfr_nextbelow @var{MPFR_OP}
Interfaces to the C language functions @cfunc{mpfr_nextabove}, @cfunc{mpfr_nextbelow}.
@end deffn

@c page
@node sign
@chapter Sign of numbers builtins


@deffn Builtin mpfr_sgn @var{MPFR_OP}
Interface to the C language function @cfunc{mpfr_sgn}.  When successful return true; otherwise
return false.  To inspect the predicate result we have to use the shell variable @env{MPFR_RV}.

@example
declare OP
declare -i MPFR_RV

mpfr_alloc_and_init OP
@{
    mpfr_set_si @WW{OP} '123' @WW{MPFR_RNDN}
    mpfr_sgn @WW{OP}

    if (( 0 < @WW{MPFR_RV} ))
    then # the number is positive
    else # the number is negative or zero
    fi
@}
mpfr_clear_and_free @WW{OP}
@end example
@end deffn


@MmuxDefinePredicateBuiltinNoEnd{mpfr_signbit}

@example
declare OP

mpfr_alloc_and_init OP
@{
    mpfr_set_si @WW{OP} 1 @WW{MPFR_RNDN}
    mpfr_signbit @WW{OP}
    if (( 0 == MPFR_RV ))
    then # it is not set
    else # it is set
    fi
@}
mpfr_clear_and_free @WW{OP}
@end example
@end deffn


@MmuxDefineBinaryBuiltin{mpfr_copysign}


@deffn Builtin mpfr_setsign @var{MPFR_ROP} @var{MPFR_OP} @var{SINT_SIGN} @var{MPFR_RND}
Interface to the C language function @cfunc{mpfr_setsign}.
@end deffn

@c page
@node exponents
@chapter Exponents--related builtins


@deffn Builtin mpfr_set_exp @var{MPFR_OP} @var{MPFR_EXP}
@deffnx Builtin mpfr_get_exp @var{MPFR_EXPVAR} @var{MPFR_OP}
Interfaces to the C language functions @cfunc{mpfr_set_exp}, @cfunc{mpfr_get_exp}.

@example
declare OP

mpfr_alloc_and_init OP
@{
    mpfr_set_si @WW{OP} 1 @WW{MPFR_RNDN}
    mpfr_set_exp @WW{OP} 2
    mpfr_just_printit_dammit @WW{OP}    @print{} 0.200000e1
@}
mpfr_clear_and_free @WW{OP}
@end example
@end deffn


@deffn Builtin mpfr_get_emin @var{MPFR_EXPVAR}
@deffnx Builtin mpfr_get_emax @var{MPFR_EXPVAR}
@deffnx Builtin mpfr_set_emin @var{MPFR_EXPVAR}
@deffnx Builtin mpfr_set_emax @var{MPFR_EXPVAR}
Interfaces to the C language functions @cfunc{mpfr_get_emin}, @cfunc{mpfr_get_emax},
@cfunc{mpfr_set_emin}, @cfunc{mpfr_set_emax}.
@end deffn


@deffn Builtin mpfr_get_emin_min
@deffnx Builtin mpfr_get_emin_max
@deffnx Builtin mpfr_get_emax_min
@deffnx Builtin mpfr_get_emax_max
Interfaces to the C language functions @cfunc{mpfr_get_emin_min}, @cfunc{mpfr_get_emin_max},
@cfunc{mpfr_get_emax_min}, @cfunc{mpfr_get_emax_max}.
@end deffn

@c page
@node miscellaneous
@chapter Miscellaneous builtins


@ref{overview conventions, Conventions used in this documentation}.

@c page
@node build options
@chapter Build options builtins


@deffn Builtin mpfr_buildopt_tls_p
@deffnx Builtin mpfr_buildopt_float128_p
@deffnx Builtin mpfr_buildopt_decimal_p
@deffnx Builtin mpfr_buildopt_gmpinternals_p
@deffnx Builtin mpfr_buildopt_sharedcache_p
Interfaces to the C language functions @cfunc{mpfr_buildopt_tls_p},
@cfunc{mpfr_buildopt_float128_p}, @cfunc{mpfr_buildopt_decimal_p},
@cfunc{mpfr_buildopt_gmpinternals_p}, @cfunc{mpfr_buildopt_sharedcache_p}.

Return true if the corresponding build option has been set; otherwise return false.
@end deffn


@deffn Builtin mpfr_get_patches
@deffnx Builtin mpfr_buildopt_tune_case
Interfaces to the C language functions @cfunc{mpfr_get_patches}, @cfunc{mpfr_buildopt_tune_case}.

Print the string to @stdout{}.
@end deffn

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node shared library
@appendix Using the shared library


@value{PACKAGE} installs a shared library:

@center @file{libmmux-bash-mpfr.so}

@noindent
and C language headers:

@center @file{mmux-bash-mpfr.h}
@center @file{mmux-bash-mpfr-config.h}

@noindent
we can write code that links to the shared library to reuse some of its facilities.  @ref{overview
linking} for details.

@menu
* shared library version::      Version functions.
* shared library config::       Library configuration.
@end menu

@c page
@node shared library version
@appendixsec Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} mmux_bash_mpfr_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int mmux_bash_mpfr_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int mmux_bash_mpfr_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int mmux_bash_mpfr_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node shared library config
@appendixsec Library configuration


The following C preprocessor symbols are defined, or not, by the installed header file
@file{mmux-bash-mpfr-config.h}.  We can use these symbols with code like:

@example
#if ((defined MMUX_BASH_MPFR_HAVE_CC_TYPE_LDOUBLE) && (1 == MMUX_BASH_MPFR_HAVE_CC_TYPE_LDOUBLE))
...
#endif
@end example


@defvr {C Preprocessor Symbol} MMUX_BASH_MPFR_HAVE_CC_TYPE_LDOUBLE
Defined and set to @samp{1} if @value{PACKAGE} supports the C language type @objtype{long double}.
This means the builtins operating on such type are defined and available.
@end defvr


@defvr {C Preprocessor Symbol} MMUX_BASH_MPFR_HAVE_CC_TYPE_DECIMAL64
Defined and set to @samp{1} if @value{PACKAGE} supports the C language type @objtype{_Decimal64}.
This means the builtins operating on such type are defined and available.
@end defvr


@defvr {C Preprocessor Symbol} MMUX_BASH_MPFR_HAVE_CC_TYPE_DECIMAL128
Defined and set to @samp{1} if @value{PACKAGE} supports the C language type @objtype{_Decimal128}.
This means the builtins operating on such type are defined and available.
@end defvr


@defvr {C Preprocessor Symbol} MMUX_BASH_MPFR_HAVE_CC_TYPE_FLOAT128
Defined and set to @samp{1} if @value{PACKAGE} supports the C language type @objtype{_Float128}.
This means the builtins operating on such type are defined and available.
@end defvr

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
the package @mmux{} Bash Pointers is available online:

@center @url{http://github.com/marcomaggi/mmux-bash-pointers/}

@noindent
the package @mbfl{} is available online:

@center @url{http://github.com/marcomaggi/mbfl/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

